# knapsack problem ナップザック問題

## 問題文

n 個の品物があり、i 番目の品物のそれぞれ重さと価値が weight[i], value[i] となっている (i = 0, 1, ..., n-1)

これらの品物から重さの総和が W を超えないように選んだときの、価値の総和の最大値を求めよ。

## 【制約】

* 1 <= n <= 100
* weight[i], value[i] は整数
* 1 <= weight[i], value[i] <= 1000
* 1 <= W <= 10000

## 【数値例】

 1)

   n = 6

   (weight,value) = {(2,3), (1,2), (3,6), (2,1), (1,3), (5,85)}

   W = 9

   答え: 94 ((3,6), (1,3), (5,85) を選んだときが最大です)

## 参考

https://qiita.com/drken/items/a5e6fe22863b7992efdb#2-%E3%83%8A%E3%83%83%E3%83%97%E3%82%B5%E3%83%83%E3%82%AF%E5%95%8F%E9%A1%8C

## 解説

* `dp[i + 1]`: `i` 番目までの品物の中から「重さが `W` を超えないように選んだときの、価値の総和の最大値」
* `dp[i + 1][w]`: `i` 番目までの品物の中から重さが `w` を超えないように選んだ時の、価値の総和の最大値 (`w: 0~W`)
* 重さが `w` を超えないように選んだ時の価値の総和の最大値のことを「計算結果」と表現する
* 常に `dp[i + 1][w]` を求めたくて、最終的に `dp[n][W]` が答えになる
* `dp[n][W]` を求めたいのにも関わらず、n, W までのすべての計算結果を出さなければならない理由は、例のように後の方で選択される商品がとてつもない価値があるケースに備えるため
  * だから各商品についての、各合計重量について価値の総和を求めていく
* 品物を一つずつ見ていき、前回までの計算結果に今回の商品を選んだ場合と選ばなかった場合とでどっちが価値が高くなるか判断していく
  * `dp[i][w]` は 前回までの `w` についての計算結果である。今回の商品を選ばなかった場合の計算結果にもなる。`dp[i][w]` を `X` とする
  * 今回の商品を選ぶということは、`weight[i]`, `value[i]` が加算されることを意味する
  * `dp[i + 1][w]` を求めるので、`weight[i]` が加わって `w` になるような `prev_w` は `w - weight[i]` で表せる
    * 当然 `prev_w + weight[i] = w` が成り立つ
    * ただし、 `w` が今回の商品の重量 `weight[i]` よりも小さい場合(`w < weight[i]`)、`weight[i]` が加わって `w` になるような `prev_w` は存在しない
      * つまり `dp[i + 1][w]` の `w` を達成するためには、今回の商品を選ぶことはできない
        * 選んだ時点で `w` を上回る
      * 結果、`w < weight[i]` の際は、`dp[i + 1][w]` は自動的に前回の計算結果の X になる
  * 今回の商品を選んだ場合の計算結果を `Y` とすると `Y = dp[i][prev_w](前回までの計算結果) + value[i](今回の価値)` とおける
  * 今回の商品を選んだ場合の計算結果(`Y`)と今回の商品を選ばなかった場合の計算結果(`X`)の大きい方を今回の計算結果とする
    * `dp[i + 1][w] = max(Y, X)` と表す事ができる

dp[2][3] が 5 であることの理由を深堀りする

0 番目: (2, 3)
1 番目: (1, 2)

weight[1] が加わって w になるような prev_w(weight[i] - w) について考える

今回の商品を選んだ場合の計算結果と選ばなかった場合の計算結果の大きい方を dp[i + 1][w] とする

選んだ場合の計算結果は、今回の商品の重さを足して w になるような総重量 prev_w について計算結果 + 今回の商品の価値を適用

選ばなかった場合は、総重量 w についての前回の計算結果を適用

今回の商品の重さを足して w になるような総重量 prev_w について計算結果とはすなわち、dp[i][weight[i] -w] である

今回の商品の価値はそのまま value[i] である

よって、今回の商品の重さを足して w になるような総重量 prev_w について計算結果 + 今回の商品の価値を適用は、dp[i][weight[i] - w] + value[i] で表すことができる

総重量 w についての前回までの計算結果は、dp[i][w]

求めたい dp[i + 1][w] は max(dp[i][weight[i] - w] + value[i], dp[i][w]) で導出できる

ただし、w < weight[i] の場合は自動的に dp[i + 1][w] は総重量 w についての前回の計算結果 dp[i][w] になる

w = 0 の時、0 < 1 のため、dp[2][0] は dp[1][0] である 0 になる

w = 1 の時、prev_w は 1 - 1 の 0 であるため、今回の商品の重さを足して w になるような総重量 prev_w について計算結果 + 今回の商品の価値というのは、dp[1][0] + 2 であり、つまり 0 + 2 の 2 である

総重量 w についての前回までの計算結果は、dp[1][1] であり、0 である

よって求めたい dp[2][1] は、max(2, 0) のため、2 となる

w = 2 の時、prev_w は 2 - 1 の 1 であるため、今回の商品の重さを足して w になるような総重量 prev_w について計算結果 + 今回の商品の価値というのは、dp[1][1] + 2 であり、つまり 0 + 2 の 2 である

総重量 w についての前回までの計算結果は、dp[1][2] であり、3 である

よって求めたい dp[2][2] は、max(2, 3) のため、3 となる

普通に考えて総重量2を超えないように価値を最大にするように (2, 3), (1, 2) から選ぶ場合、商品 0 だけを選ぶはず

w = 3 の時、prev_w は 3 - 1 の 2 であるため、今回の商品の重さを足して w になるような総重量 prev_w について計算結果 + 今回の商品の価値というのは、dp[1][2] + 2 であり、つまり 3 + 2 の 5 である

総重量 w についての前回までの計算結果は、dp[1][3] であり、3 である

よって求めたい dp[2][3] は、max(5, 3) のため、5 となる

普通に考えて総重量3を超えないように価値を最大にするように (2, 3), (1, 2) から選ぶ場合、商品 0, 1 両方とも選ぶはず



```
dp[0][0]: 0
dp[0][1]: 0
dp[0][2]: 0
dp[0][3]: 0
dp[0][4]: 0
dp[0][5]: 0
dp[0][6]: 0
dp[0][7]: 0
dp[0][8]: 0
dp[0][9]: 0

dp[1][0]: 0
dp[1][1]: 0
dp[1][2]: 3
dp[1][3]: 3
dp[1][4]: 3
dp[1][5]: 3
dp[1][6]: 3
dp[1][7]: 3
dp[1][8]: 3
dp[1][9]: 3

dp[2][0]: 0
dp[2][1]: 2
dp[2][2]: 3
dp[2][3]: 5
dp[2][4]: 5
dp[2][5]: 5
dp[2][6]: 5
dp[2][7]: 5
dp[2][8]: 5
dp[2][9]: 5

dp[3][0]: 0
dp[3][1]: 2
dp[3][2]: 3
dp[3][3]: 6
dp[3][4]: 8
dp[3][5]: 9
dp[3][6]: 11
dp[3][7]: 11
dp[3][8]: 11
dp[3][9]: 11

dp[4][0]: 0
dp[4][1]: 2
dp[4][2]: 3
dp[4][3]: 6
dp[4][4]: 8
dp[4][5]: 9
dp[4][6]: 11
dp[4][7]: 11
dp[4][8]: 12
dp[4][9]: 12

dp[5][0]: 0
dp[5][1]: 3
dp[5][2]: 5
dp[5][3]: 6
dp[5][4]: 9
dp[5][5]: 11
dp[5][6]: 12
dp[5][7]: 14
dp[5][8]: 14
dp[5][9]: 15

dp[6][0]: 0
dp[6][1]: 3
dp[6][2]: 5
dp[6][3]: 6
dp[6][4]: 9
dp[6][5]: 85
dp[6][6]: 88
dp[6][7]: 90
dp[6][8]: 91
dp[6][9]: 94
```

  | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
-- | -- | -- | -- | -- | -- | -- | -- | -- | -- | --
0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0 | 0
1 | 0 | 0 | 3 | 3 | 3 | 3 | 3 | 3 | 3 | 3
2 | 0 | 2 | 3 | 5 |   |   |   |   |   |  
3 |   |   |   |   |   |   |   |   |   |  
4 |   |   |   |   |   |   |   |   |   |  
5 |   |   |   |   |   |   |   |   |   |  
6 |   |   |   |   |   |   |   |   |   |  


